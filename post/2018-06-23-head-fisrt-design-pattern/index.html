<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/><meta name="google-site-verification" content="JA_ocNhbTh2OZYc6XdvGU86Tu-KrppkZddT3_sfwTDU"/><meta name="generator" content="Gatsby 4.24.8"/><meta data-react-helmet="true" name="og:description" content="Jaehyun Baek blog"/><meta data-react-helmet="true" name="og:image" content="https://byjay.github.io/img/og.jpeg"/><meta data-react-helmet="true" name="title" content="Head First Design Pattern 요약 정리"/><meta data-react-helmet="true" name="description"/><meta data-react-helmet="true" name="keywords" content="Head First Design Pattern 요약 정리"/><meta data-react-helmet="true" name="image" content="https://byjay.github.io/img/default.jpeg"/><meta data-react-helmet="true" property="og:description"/><meta data-react-helmet="true" property="og:title" content="Head First Design Pattern 요약 정리"/><meta data-react-helmet="true" property="og:image" content="https://byjay.github.io/img/default.jpeg"/><style data-href="/styles.ce7fcc8d1dcd281464b0.css" data-identity="gatsby-global-css">article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box;font:112.5%/1.45em georgia,serif;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{word-wrap:break-word;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt";font-family:georgia,serif;font-kerning:normal}img{margin:0 0 1.45rem;max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{color:inherit;font-weight:700;line-height:1.1;margin:0 0 1rem;padding:0;text-rendering:optimizeLegibility}h2{font-size:1.45rem}h3{font-size:1.3rem}h3,h4{color:inherit;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{color:inherit;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{word-wrap:normal;border-radius:3px;font-size:.85rem;line-height:1.42;margin:0 0 1.45rem;overflow:auto;padding:1.45rem}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;width:100%}fieldset,table{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{background:var(--border-color);border:none;height:1px;margin:0 0 calc(1.45rem - 1px);padding:0}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid var(--border-color);padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}h1,h2,h3:lang(ko){word-break:keep-all}:root{--oc-gray-0:#f8f9fa;--oc-gray-0-rgb:248,249,250;--oc-gray-1:#f1f3f5;--oc-gray-1-rgb:241,243,245;--oc-gray-2:#e9ecef;--oc-gray-2-rgb:233,236,239;--oc-gray-3:#dee2e6;--oc-gray-3-rgb:222,226,230;--oc-gray-4:#ced4da;--oc-gray-4-rgb:206,212,218;--oc-gray-5:#adb5bd;--oc-gray-5-rgb:173,181,189;--oc-gray-6:#868e96;--oc-gray-6-rgb:134,142,150;--oc-gray-7:#495057;--oc-gray-7-rgb:73,80,87;--oc-gray-8:#343a40;--oc-gray-8-rgb:52,58,64;--oc-gray-9:#212529;--oc-gray-9-rgb:33,37,41;--bg-color:#fff;--border-color:var(--oc-gray-2);--title-color:var(--oc-gray-8);--subtitle-color:var(--oc-gray-7);--text-color:var(--oc-gray-8);--hover-color:var(--oc-gray-2)}@media (prefers-color-scheme:dark){:root{--bg-color:var(--oc-gray-8);--border-color:var(--oc-gray-7);--title-color:var(--oc-gray-4);--subtitle-color:var(--oc-gray-4);--text-color:var(--oc-gray-4);--hover-color:var(--oc-gray-9)}}*{color:var(--text-color);font-family:Noto Sans KR,Noto Sans,sans-serif;font-weight:400}body,html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:var(--bg-color);margin:0}@media only screen and (max-width:480px){html{font-size:100%}}li,p{font-size:1.15rem;font-weight:500;line-height:1.7rem}blockquote{background:var(--hover-color);border-left:10px solid var(--border-color);margin:1.5em 0;padding:.5em .5rem .5rem 2rem;quotes:"\201C" "\201D" "\2018" "\2019"}blockquote:before{color:#ccc;content:open-quote;font-size:4em;line-height:.1em;margin-left:-.5em;vertical-align:-.7em}</style><title data-react-helmet="true">Head First Design Pattern 요약 정리</title><style data-styled="" data-styled-version="5.3.6">.WwZvZ{text-align:center;}/*!sc*/
data-styled.g1[id="BuyMe__Wrapper-sc-8e0gb5-0"]{content:"WwZvZ,"}/*!sc*/
.dJKhdI{margin:0 auto;padding:0.5rem;text-align:left;border-bottom:1px solid var(--border-color);margin-bottom:1.0rem;-webkit-transition:0.4s;transition:0.4s;position:fixed;width:100%;background-color:var(--bg-color);}/*!sc*/
data-styled.g2[id="Profile__Wrapper-sc-z34zrb-0"]{content:"dJKhdI,"}/*!sc*/
.dEtezi{display:inline-block;font-weight:bold;font-size:1.3rem;margin:0.2rem 0;padding:0.25rem 0.5rem;color:var(--title-color);-webkit-transition:all 0.3s ease;transition:all 0.3s ease;}/*!sc*/
.dEtezi:hover{background-color:var(--hover-color);border-radius:3px;}/*!sc*/
data-styled.g3[id="Profile__Title-sc-z34zrb-1"]{content:"dEtezi,"}/*!sc*/
.jxzdFN{color:var(--subtitle-color);font-size:0.8rem;line-height:1.2rem;margin:0;}/*!sc*/
.jxzdFN li{display:inline;}/*!sc*/
data-styled.g4[id="Profile__NavList-sc-z34zrb-2"]{content:"jxzdFN,"}/*!sc*/
.izZNPE{-webkit-text-decoration:none;text-decoration:none;color:var(--subtitle-color);padding:0.25rem;margin:0.25rem;-webkit-transition:all 0.3s ease;transition:all 0.3s ease;}/*!sc*/
.izZNPE:hover{background-color:var(--hover-color);border-radius:3px;}/*!sc*/
data-styled.g5[id="Profile__OutLink-sc-z34zrb-3"]{content:"izZNPE,"}/*!sc*/
.kxymRE{padding:120px 50px;-webkit-transition:all 0.3s ease;transition:all 0.3s ease;background-color:var(--bg-color);}/*!sc*/
@media (max-width:48em){.kxymRE{padding:100px 20px;}}/*!sc*/
data-styled.g6[id="Layout__Content-sc-15rk51y-0"]{content:"kxymRE,"}/*!sc*/
.ckUBLT{max-width:600px;margin:auto;}/*!sc*/
data-styled.g7[id="post__Wrapper-sc-q9naw2-0"]{content:"ckUBLT,"}/*!sc*/
.jfNZGY{font-weight:300;font-size:0.6rem;text-align:right;color:var(--subtitle-color);}/*!sc*/
data-styled.g8[id="post__Time-sc-q9naw2-1"]{content:"jfNZGY,"}/*!sc*/
.ilPCFk{font-weight:bold;font-size:2rem;line-height:2rem;text-align:center;margin:0.5rem 0;word-break:keep-all;color:var(--title-color);}/*!sc*/
data-styled.g9[id="post__Title-sc-q9naw2-2"]{content:"ilPCFk,"}/*!sc*/
.hLtMlZ{color:var(--subtitle-color);font-size:0.9rem;word-break:keep-all;text-align:center;margin:0.5rem 0;}/*!sc*/
data-styled.g10[id="post__Description-sc-q9naw2-3"]{content:"hLtMlZ,"}/*!sc*/
@media (max-width:48em){.fSeZHP iframe{width:100%;height:100%;}}/*!sc*/
.fSeZHP img{display:block;margin:0 auto;}/*!sc*/
.fSeZHP h3{line-height:1.4;}/*!sc*/
data-styled.g11[id="post__Content-sc-q9naw2-4"]{content:"fSeZHP,"}/*!sc*/
</style><link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml"/><link rel="shortcut icon" href="/static/favicon-a72ca269f6d3805268e0b7da0eb545e6.png"/><link rel="preconnect" href="https://fonts.googleapis.com/css?family=Noto+Sans|Noto+Sans+KR&amp;display=swap"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><nav class="Profile__Wrapper-sc-z34zrb-0 dJKhdI"><div class="Profile__Title-sc-z34zrb-1 dEtezi"><a href="/" style="text-decoration:none;color:inherit">Jaehyun Baek</a></div><ul class="Profile__NavList-sc-z34zrb-2 jxzdFN"><li><a href="/" class="Profile__OutLink-sc-z34zrb-3 izZNPE">home</a></li>·<li><a href="/about" class="Profile__OutLink-sc-z34zrb-3 izZNPE">about</a></li>·<li><a href="/search" class="Profile__OutLink-sc-z34zrb-3 izZNPE">search</a></li></ul></nav><div class="Layout__Content-sc-15rk51y-0 kxymRE"><div class="post__Wrapper-sc-q9naw2-0 ckUBLT"><h1 class="post__Title-sc-q9naw2-2 ilPCFk">Head First Design Pattern 요약 정리</h1><div class="post__Description-sc-q9naw2-3 hLtMlZ"></div><div class="post__Time-sc-q9naw2-1 jfNZGY">2018-06-23</div><div class="post__Content-sc-q9naw2-4 fSeZHP"><h2>Table of Contents</h2>
<hr>
<ul>
<li><a href="#observer">Observer</a></li>
<li><a href="#strategy">Strategy</a></li>
<li><a href="#decorator">Decorator</a></li>
<li><a href="#factory-method">Factory Method</a></li>
<li><a href="#singleton">Singleton</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#adapter">Adapter</a></li>
<li><a href="#facade">Facade</a></li>
<li><a href="#template-method">Template Method</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#composite">Composite</a></li>
</ul>
<h2><a name="observer"></a>Observer</h2>
<hr>
<p>옵저버 패턴에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 상태변화를 알리고, 내용을 갱신해주는 일대다(one to many)의존성을 정의한다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>한 객체의 상태가 변화할 때, 즉각적으로 다른 객체에게 알려야 할 때 옵저버 패턴을 고려할 수 있다. 상태 변화를 느슨한 결합으로 전파가능하다.</li>
<li>전파할 데이터 상태를 가지고 있고, 알리는 객체를 subject라고 하고 변화를 구독하는 객체를 observer 라고한다.</li>
</ul>
<h3>code with python</h3>
<pre><code class="language-python">class Subject:
    def __init__(self):
        self.__observers = []

    def register_observer(self, observer):
        self.__observers.append(observer)

    def unregister_observer(self, observer):
        if observer in self.__observers
            self.__observer.remove(observer)

    def notify_observers(self, *args, **kwargs):
        for observer in self.__observers:
            observer.notify(self, *args, **kwargs)

class Observer:
    def __init__(self, subject):
        subject.register_observer(self)

    def notify(self, subject, *args, **kwargs):
        print('Got', args, kwargs, 'From', subject)


subject = Observable()
observer = Observer(subject)
subject.notify_observers('test')
</code></pre>
<h3>misc</h3>
<ul>
<li>느슨한 결합 : 상호작용은 하지만 서로에 대해 잘 모른다.</li>
</ul>
<h2><a name="strategy"></a> Strategy</h2>
<hr>
<p>알고리즘군을 정의하고 각각 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트래티지를 활용하면 알고리즘과 알고리즘을 사용하는 클라언트를 분리하여 관리할 수 있다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>상속을 남용하면 문제가 생긴다. 부모클래스의 메소드가 자식클래스에 영향을 미처 수정시 사이드이팩트가 발생 할 수 있고, 오버라이딩 이용하면 서브클래스에서 코드가 중복된다.</li>
<li>부모 클래스의 인터페이스를 사용한다면 결국 서브클래스에서 모두 구현하므로 코드 재사용 관점에서 비효율적이다.</li>
<li>클래스의 행위를 따로 클래스(인터페이스 or 추상클래스)로 정의하고,여러 상황의 행위를 구현한다. 이 행동이 정의된 클래스를, 행동을 할 클래스에서 이용한다.</li>
<li>특정 '행동'도 객체라고 사고 할 수 있다. 행위를 하고자하는 클래스와, 행위 클래스가 나눈다. 이는 행위의 주체 객체에 행위를 '구성' 할 수 있다.</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">
// 행위 인터페이스
public interface FlyBehavior {
    public void fly() { }
}

// 행위 구현체
public class FlyWithWings implements FlyBehavior {
    public void fly() {
        System.out.println("I'm flying!!");
    }
}

// 행위를 할 객체의 클래스
public abstract class Duck {
    FlyBehavior flyBehavior;

    public Duck() { }

    public void setFlyBehavior(FlyBehavior fb) {
        flyBehavior = fb;
    }

    // 행위를 표현하는 객체 사용
    public void performFly() {
        flyBehavior.fly();
    }
    // 서브클래스에서 공통적으로 정의되어야할 메소드
    abstract void display();

    // 서브클래스 모두 공통적으로 같은 행위를 하는 메소드
    public void swim() {
        System.out.println("All ducks float, even decoys!");
    }
}

public class WingsDuck implements Duck {
    public WingDuck() {}
}

public class Runner() {
    public static void main(String[] args) {
        Duck wingDuck = new WingDuck();
        wingDuck.setFlyBehavior(new FlyWithWings());
    }
}
</code></pre>
<h2><a name="decorator"></a> Decorator</h2>
<hr>
<p>객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>
<p>추상 메소드를 정의하면 서브클레스에서 그 메소드를 새로 정의해야 한다. 음료 추상클래스가 있고, 추상 클래스의 여러 커피 종류가 있는 상황을 생각 할 수 있다. 이러한 상황은 컴파일타임에서 서브클래스의 메소드들이 결정되게 된다.</p>
</li>
<li>
<p>특정 구상 구성요소인지를 확인한 다음 어떤 작업을 처리한느 경우에는 데코레이터 코드가 제대로 작동하지 않을 수 있다. 아래 예제의 HouseBlend 만 Mocha를 추가 했을 때 cost 할인해준다는 식의 접근은 불가하다. 따라서 추상 구성요소 형식을 바탕으로 돌아가는 코드에 대해서 더욱 적합하다.</p>
</li>
<li>
<p>데코레이터의 형식이 그 데코리에터로 감싸는 객체의 형식과 같게 하여, 기존의 클래스를 확장하면서 코드 변화에는 닫혀있는 OCP(open closed principle)를 만족 할 수 있다.</p>
</li>
<li>
<p>데코레이터 패턴을 과하게 이용하다보면, 즉 감싸는 클래스가 많아지면,  코드를 유지보수하는데 어려움을 줄 수 있다.</p>
</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">public abstract class Beverage {
    public abstract double cost();
}

// 첨가물을 나타내는 추상클래스(데코레이터)
public abstract class CodimentDecorator extends Beverage {}

public class Esopresso extends Beverage {
    public double cost() {
        return 1.99;
    }
}

public class HouseBlend extends Beverage {
    public double code() {
        return .89;
    }
}

public class Mocha extends CodimentDecorator {
    Beverage beverage;

    public Mocha (Beverage beverage) {
        this.beverage = beverage;
    }

    public double cost() {
        // 첨가물의 가격을 더해준다.
        return 0.2 + this.beverage.cost();
    }
}

public static void main(String args[]) {
    Beverage beverage = Esopresso();
    // 모카 두번 추가!
    beverage = new Mocha(beverage);
    beverage = new Mocha(beverage);
    Systme.out.println("에소프레소에 모카 두번!" + beverage.cost());
}
</code></pre>
<h3>misc</h3>
<ul>
<li>OPC(open closed principle) : 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다. 그러나 무조건 OCP 를 적용하는 것은 불필요하게 복잡하고 유지보수하기 힘든 코드를 만들 수 있으므로 주의해야 한다.</li>
</ul>
<h2><a name="factory-method"></a>Factory Method</h2>
<hr>
<p>객체의 생성하는 것을 캡슐화하는 패턴을 factory 라고 한다. 특히 서브클래스에서 어떤 객체를 만들지 강제하는 것을 factory method 패턴이라고 한다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>
<p>concrete class를 많이 사용하면 새로운 concrete class 를 추가 할 때마다 코드를 고쳐야 하는 경우가 있다. 즉 변화에 닫혀있는 코드가 된다.</p>
<pre><code class="language-java">Duck duck
if(sth) {
    duck = new MallardDuck();
} else {
    duck = new RubberDuck();
}
</code></pre>
</li>
<li>
<p>위와 같이 객체를 생성하는 부분을 캡슐한 class를 factory 라고 한다. 단순히 factory 클래스로 코드를 옮겼을 뿐이지만, 충분히 가치가 있다. OOP 에서 객체생성은 피할 수 없으므로 이를 잘 관리하는 것은 중요하다.</p>
</li>
<li>
<p>팩토리보다는 팩토리메소드 패턴이 언터페이스를 정의하고 서브클래스의 구현을 강제하여 일관된 패턴을 가져갈 수 있다. (아래 예제 코드 참고)</p>
</li>
<li>
<p>팩토리에서 concrete class 를 의존하게 되면, 생성할 객체의 종류가 늘어남에 따라 팩토리에 의존성들이 늘어나게 된다. 이때 생성할 객체를 추상화하여 그것을 의존하면, 팩토리는 추상화된 것에 의존하게 된다. 이러한 것을 의존성 뒤집기라 한다.</p>
</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">// factoray method pattern
public abstract class PizzaStore {

    public Pizza orderPizza(String type){
        Pizza pizza;
        pizza = createPizza(type);

        pizza.prepare();

        return pizza;
    }

    // 서브클래스에서 객체 생성하는 작업을 캡슐화 한다.
    protected abstarctPizza createPizza(String type); 
}
</code></pre>
<h3>misc</h3>
<ul>
<li>
<p>concrete class: abstract class, interface가 아닌, 모든 오퍼레이션의 구현을 제공하는 class. 번역으로 '구상클래스'라고도 한다.</p>
</li>
<li>
<p>의존성 뒤집기:</p>
<p><img src="/img/programming/iod1.png" alt="iod1" title="iod1"></p>
<p><img src="/img/programming/iod2.png" alt="iod2" title="iod2"></p>
</li>
</ul>
<h3>reference</h3>
<ul>
<li><a href="https://www.oreilly.com/library/view/head-first-design/0596007124/ch04.html">https://www.oreilly.com/library/view/head-first-design/0596007124/ch04.html</a></li>
</ul>
<h2><a name="singleton"></a>Singleton</h2>
<hr>
<p>해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>
<p>사실상 객체중에 하나만 있으면 되는것이 많다. 쓰레드풀이라던지, 사용자 설정등이 그러하다. 컴퓨팅 자원관점에서도 그러하고 개념적인 설계 관점에서도 그러하다.</p>
</li>
<li>
<p>전역 변수로 관리하면 저녁 네임스페이스가 관리되지 않고, 어플리케이션이 시작하자 마자 자원을 차지하기 때문에 오버헤드가 있을 수 있다. 싱글턴 패턴이 전역 네임스페이스의 문제는 완벽히 해결하지 못해도, 인스턴스를 lazy load 해준다는 관점에서는 그 효용이 명백하다. 객체 생성비용이 많을 때에는 lazy load 를 고려해볼 수 있다.</p>
</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">
// simple singleton
public class Singleton {
    private static Singleton uniqueInstance;

    // 외부에서 생성자 호출를 막는다.
    private Singleton() {};

    // 'synchronized' 를 사용하여 thread safe 한 코드를 만든다. 
    // uniqueInstance가 없을 때 멀티 쓰레드가 동시에 getInstance 를 호출하면 객체가 여러개 생길 수 있다.
    public static synchronized Singleton getInstance(){
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}

// synchronized를 이용한 method 동기화의 오버헤드를 부담이 되는 경우라면, 처음 class가 load 될 때 생성 할 수 있다.
public class SingletonWithoutSyncronizedMethod {
    // JVM 에서는 class loader 마다 서로다른 네임스페이스를 정의 하기 때문에,
    // 클래스가 여러번 로드되어 싱글턴이 여러개 만들어질 수 있으니 클래스 로더를 조심히 살피자.
    private static SingletonWithoutSyncronizedMethod uniqueInstance = new SingletonWithoutSyncronizedMethod();

    // 외부에서 생성자 호출를 막는다.
    private SingletonWithoutSyncronizedMethod() {};.
    public static synchronized SingletonWithoutSyncronizedMethod getInstance(){
        return uniqueInstance;
    }
}
</code></pre>
<h2><a name="command"></a>Command</h2>
<hr>
<p>요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>
<p>커맨드 패턴에는 명령(command), 수신자(receiver), 발동자(invoker), 클라이언트(client)의 네개의 용어가 항상 따른다.</p>
<ul>
<li>커맨드 객체는 수신자 객체를 가지고 있으며, 수신자의 메서드를 호출하고, 이에 수신자는 자신에게 정의된 메서드를 수행한다.</li>
<li>클라이언트 객체는 어느 시점에서 어떤 명령을 수행할지를 결정한다. 명령을 수행하려면, 클라이언트 객체는 invoker 객체로 커맨드 객체를 전달한다.</li>
</ul>
</li>
<li>
<p>invoker 입장에서는 Command 객체의 정의된 excute 만 사용하면 되기때문에 캡슐화의 이점을 얻는다. (아래 코드 참고)</p>
</li>
<li>
<p>커맨드 패턴을 이용하면 Command 객체를 이용하고 한참 후에도 일련의 computation 을 진행할 수 있다. 이러한 시나리오는 스케줄러, 스레드풀, 작업 큐 같은 상황에서 유용하다. 작업 큐는 커맨드들의 excute 를 호출하기만 하면 된다.</p>
</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">
/*the Invoker class*/
public class Switch {
    private Command flipUpCommand;
    private Command flipDownCommand;

    public Switch(Command flipUpCmd,Command flipDownCmd){
        this.flipUpCommand=flipUpCmd;
        this.flipDownCommand=flipDownCmd;
    }

    public void flipUp(){
         flipUpCommand.execute();
    }

    public void flipDown(){
         flipDownCommand.execute();
    }
}


/*Receiver class*/
public class Light{
     public Light(){  }

     public void turnOn(){
        System.out.println("The light is on");
     }

     public void turnOff(){
        System.out.println("The light is off");
     }
}


/*the Command interface*/
public interface Command{
    void execute();
}

public class TurnOnLightCommand implements Command{
   private Light theLight;

   public TurnOnLightCommand(Light light){
        this.theLight=light;
   }

   public void execute(){
      theLight.turnOn();
   }
}


/*The test class*/
public class TestCommand{
   public static void main(String[] args){
       Light light=new Light();
       Command switchUp=new TurnOnLightCommand(light);
       Command switchDown=new TurnOffLightCommand(light);

       Switch s=new Switch(switchUp,switchDown);

       s.flipUp();
       s.flipDown();
   }
}

</code></pre>
<h3>reference</h3>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%A7%A8%EB%93%9C_%ED%8C%A8%ED%84%B4">https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%A7%A8%EB%93%9C_%ED%8C%A8%ED%84%B4</a></li>
</ul>
<h2><a name="adapter"></a>Adapter</h2>
<hr>
<p>한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다. 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>
<p>기존 클래스를 사용하고 싶으나, 인터페이스가 다른 경우. 인터페이스를 맞추는 패턴</p>
</li>
<li>
<p>어댑터 클래스에서 목표로 하는 객체를 받아서 구현하는 object adapter 가 있고, 다중 상속을 통해 클라이언트에 공개할 인터페이스는 public 으로 상속받고, 내부 구현을 private 으로 감추는 class adapter 가 있다.</p>
</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">
 public interface Duck {
    public void quack();
    public void fly();
 }

 public class MallardDuck implements Duck {
    public void quack() {
        System.out.println("Quack");
    }
    public void fly() {
        System.out.println("I'm flying");
    }
 }
 public interface Turkey {
    public void gobble();
    public void fly();
 }

public class TurkeyAdapter implements Duck {
    Turkey turkey;
    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    public void quack(){
        turkey.gobble();
    }

    public void fly() {
        turkey.fly();
    }
 }
</code></pre>
<h2><a name="facade"></a>Facade</h2>
<hr>
<p>어떤 서브세스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공합니다. 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>개념적인 하나의 일을 하기 위해서, 여러객체와 상호작용을 많이 하는 경우 고수준의 인터페이스를 정의할 필요가 있다. 더욱 서브시스템의 객체들의 인터페이스가 지저분한 경우 이러한 wrapper 를 고려할 수 있다.</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">class CPU {
    public void freeze() { ... }
    public void jump(long position) { ... }
    public void execute() { ... }
}

class HardDrive {
    public byte[] read(long lba, int size) { ... }
}

class Memory {
    public void load(long position, byte[] data) { ... }
}

/* Facade */
class ComputerFacade {
    private CPU processor;
    private Memory ram;
    private HardDrive hd;

    public ComputerFacade() {
        this.processor = new CPU();
        this.ram = new Memory();
        this.hd = new HardDrive();
    }

    public void start() {
        processor.freeze();
        ram.load(BOOT_ADDRESS, hd.read(BOOT_SECTOR, SECTOR_SIZE));
        processor.jump(BOOT_ADDRESS);
        processor.execute();
    }
}

/* Client */
class You {
    public static void main(String[] args) {
        ComputerFacade computer = new ComputerFacade();
        computer.start();
    }
}
</code></pre>
<h3>misc</h3>
<ul>
<li>최소 지식 원칙 - 복잡하게 상호작용하는 의존성들을 최소화 한다.</li>
</ul>
<h2><a name="template-method"></a>Template Method</h2>
<hr>
<p>알고리즘의 골격을 정의합니다. 알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있습니다. 템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 서브클래스에서 특정 단계를 재정의할 수 있습니다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>'비슷한' 일련의 알고리즘을 수행해야 한다면, 바뀌는 부분과 바뀌지 않는 부분을 명확하게 구분하야한다. 가령 여러 절차적인 메소드의 틀을 final 메소드로 구현하여 틀을 만들고, 그 안에서 공통으로 쓰이지 않는 메소드들을 abstract 메소드로 정의하면 코드 중복을 줄이고 확장성 있는 코드를 짤 수 있다.</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">public abstract class Beverage {
    final vodi prepare() {
        boilWater();
        brew();
        pourInCup()
    }

    abstract void brew();

    void boilWater() {
        System.out.println("boilWater");
    }

    void pourInCup() {
        System.out.println("pourInCup");
    }
}

public class Tea extends Beverage {
    public void brew() {
        System.out.println("Tea brew");
    }
}


public class Coffee extends Beverage {
    public void brew() {
            System.out.println("Coffee brew");
    }
}
</code></pre>
<h2><a name="iterator"></a>Iterator</h2>
<hr>
<p>컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공해 줍니다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>배열이든 스택이든 해시테이블이든, 어떠한 객체든 전부 순회하는 경우 객체 따라 순회하는 코드를 짜야한다면 iterator 를 고려해 볼 수 있다. 이 때 concrete class 에 맞춰서 분기하기보다 인터페이스에 의존하도록 하면 좋다. 만약 또다른 객체를 순회해야한다면 그 객체에 맞게 순환문도 추가해야 한다.</li>
</ul>
<h3>code with java</h3>
<pre><code class="language-java">// 참고로 java.util.Iterator 인터페이스가 있다.
public interface Iterator {
    boolean hasNext();
    Object next();
}

public class DinerMenuIterator implements Iterator {
    MenuItem[] items;
    int position = 0;
 
    public DinerMenuIterator(MenuItem[] items) {
        this.items = items;
    }
 
    public MenuItem next() {
        MenuItem menuItem = items[position];
        position = position + 1;
        return menuItem;
    }
 
    public boolean hasNext() {
        if (position >= items.length || items[position] == null) {
            return false;
        } else {
            return true;
        }
    }
}
public class PancakeHouseMenuIterator implements Iterator {
    ArrayList&#x3C;MenuItem> items;
    int position = 0;

    public PancakeHouseMenuIterator(ArrayList&#x3C;MenuItem> items) {
        this.items = items;
    }

    public MenuItem next() {
        MenuItem item = items.get(position);
        position = position + 1;
        return item;
    }

    public boolean hasNext() {
        if (position >= items.size()) {
            return false;
        } else {
            return true;
        }
    }
}
</code></pre>
<h2><a name="composite"></a>Composite</h2>
<hr>
<p>객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들 수 있습니다. 이 패턴을 이용하면 클라이언트에서 개별 객체와 다른 객체들로 구성된 복합 객체를 똑같은 방법으로 다룰 수 있습니다.</p>
<h3>background &#x26; pattern</h3>
<ul>
<li>메뉴 리스트 및에 하위 메뉴 리스트를 구현한다고 하자. 전형적인 부분-전체 계층구조(part-whole hierarchy)이다.</li>
</ul>
<h3>code with python</h3>
<pre><code class="language-python">from abc import ABC, abstractmethod

NOT_IMPLEMENTED = "You should implement this."


class Graphic(ABC):
    @abstractmethod
    def print(self):
        raise NotImplementedError(NOT_IMPLEMENTED)


class CompositeGraphic(Graphic):
    def __init__(self):
        self.graphics = []

    def print(self):
        for graphic in self.graphics:
            graphic.print()

    def add(self, graphic):
        self.graphics.append(graphic)

    def remove(self, graphic):
        self.graphics.remove(graphic)


class Ellipse(Graphic):
    def __init__(self, name):
        self.name = name

    def print(self):
        print("Ellipse:", self.name)


ellipse1 = Ellipse("1")
ellipse2 = Ellipse("2")
ellipse3 = Ellipse("3")
ellipse4 = Ellipse("4")

graphic = CompositeGraphic()
graphic1 = CompositeGraphic()
graphic2 = CompositeGraphic()

graphic1.add(ellipse1)
graphic1.add(ellipse2)
graphic1.add(ellipse3)

graphic2.add(ellipse4)

graphic.add(graphic1)
graphic.add(graphic2)

graphic.print()
</code></pre></div><div class="BuyMe__Wrapper-sc-8e0gb5-0 WwZvZ"><a href="https://www.buymeacoffee.com/jaehyunbaekblog" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/black_img.png" alt="Buy Me A Coffee"/></a></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/post/2018-06-23-head-fisrt-design-pattern/";window.___webpackCompilationHash="0e3078864e5db1e6a75b";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-c9fa82aa5b1f9c65f078.js"],"app":["/app-44b06495a16a1f63fe98.js"],"component---src-pages-404-js":["/component---src-pages-404-js-c4c109740f30c11562b4.js"],"component---src-pages-about-js":["/component---src-pages-about-js-028482cf30a02afdd429.js"],"component---src-pages-index-js":["/component---src-pages-index-js-657fa1506dd5f11a02eb.js"],"component---src-templates-post-js":["/component---src-templates-post-js-ad0266cea27fb56518d9.js"]};/*]]>*/</script><script src="/polyfill-c9fa82aa5b1f9c65f078.js" nomodule=""></script><script src="/app-44b06495a16a1f63fe98.js" async=""></script><script src="/532a2f07-0e90e23d205d85fea829.js" async=""></script><script src="/framework-a4e155cd0476dc1ca208.js" async=""></script><script src="/webpack-runtime-75a49eee3feab28adc1d.js" async=""></script></body></html>